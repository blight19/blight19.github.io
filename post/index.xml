<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 闫的Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on 闫的Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux是怎样工作的读书笔记-第三章</title>
      <link>/post/linux_in_practice3/</link>
      <pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/linux_in_practice3/</guid>
      <description>进程管理 创建进程 目的： 将同一个程序分成多个进程进行处理 创建另一个程序 Linux提供了两个函数：fork和execve fork函数 父进程执行f</description>
    </item>
    <item>
      <title>Linux是如何工作的2</title>
      <link>/post/linux_in_practice2/</link>
      <pubDate>Thu, 11 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/linux_in_practice2/</guid>
      <description>OS并非仅由内核构成，还有许多用户模式下运行的程序。有些以库的形式存在，有些作为单独进程运行。 系统调用 进程控制(创建和删除) 内存管理(分配和</description>
    </item>
    <item>
      <title>进程间通信方式</title>
      <link>/post/process2process_communication/</link>
      <pubDate>Thu, 11 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/process2process_communication/</guid>
      <description>## 使用操作系统中的管道来进行通信 创建管道 syscall.Mkfifo(path, 0666) 读取和写入 func read() { fmt.Println(&amp;#34;open a named pipe file for read.&amp;#34;) file, _ := os.OpenFile(pipeFile, os.O_RDWR, os.ModeNamedPipe) reader := bufio.NewReader(file) for { line, err := reader.ReadBytes(&amp;#39;\n&amp;#39;) fmt.Println(&amp;#34;read...&amp;#34;) if err == nil { fmt.Print(&amp;#34;load string: &amp;#34; + string(line)) } } } func write() { f,</description>
    </item>
    <item>
      <title>Linux是怎样工作的读书笔记-第一章</title>
      <link>/post/linux_in_practice1/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/linux_in_practice1/</guid>
      <description>每个程序单独调用设备的话，对于编写十分复杂，开发成本高，并且多个进程同时调用一个设备会产生问题。为了解决这个问题，单独编写驱动程序来和设备交</description>
    </item>
    <item>
      <title>爱上跑步笔记</title>
      <link>/post/learn_running/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/learn_running/</guid>
      <description>呼吸方法 有意识的练习呼吸，节奏开始可以使两步一呼，两步一吸，后面变为三步 腰腹核心训练，卷腹，平板支撑 跑步之前热身 最好口鼻同时呼吸 岔气的话，使</description>
    </item>
    <item>
      <title>负载均衡算法2</title>
      <link>/post/smooth_weight_round_robin2/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/smooth_weight_round_robin2/</guid>
      <description>负载均衡算法&amp;ndash;平滑加权轮询法2 那上篇文章我们了解了平滑加权轮询，同时实现了一个简单的golang版本。 那么，我们仔细想像下还有没</description>
    </item>
    <item>
      <title>负载均衡算法</title>
      <link>/post/smooth_weight_round_robin/</link>
      <pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/post/smooth_weight_round_robin/</guid>
      <description>负载均衡算法&amp;ndash;平滑加权轮询法 平常比较常用的负载均衡算法有 随机 一致性哈希 轮询 加权轮询 其中，加权轮询算法常用的是平滑加权轮询法，比如</description>
    </item>
    <item>
      <title>An Example Post</title>
      <link>/post/my-first-post/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      <guid>/post/my-first-post/</guid>
      <description>第一篇文章 测试测试</description>
    </item>
    <item>
      <title>内存管理总结</title>
      <link>/post/memory/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      <guid>/post/memory/</guid>
      <description>虚拟内存 由于多进程运行，他们之间都需要使用物理内存，而需要让他们之间能够共用物理内存并减少内存碎皮的产生，所以需要使用虚拟内存。 虚拟内存有内</description>
    </item>
  </channel>
</rss>
